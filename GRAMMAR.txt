// grammar rules (EBNF-like)
// to be theoretically generated by
//  an LL(2) parser-generator
// but it's going to use a handwritten
//  recursize-descent parser

language:
	{toplevel}

toplevel:
	module
	fn_decl
	type_decl
	let_decl
	impl
	iface

module:
	"module" ID
	"use" ID

name:
	ID "::" ID
	ID

fn_decl:
	fn_sig fn_body
fn_sig:
	"fn" ID "(" [var {"," var}] ")"
fn_body:
	"=" exp
	"extern" STRING ":" type
	block_exp
var:
	ID ":" type


type_decl:
	"type" type "=" type
	"type" type "{" {var} "}"

type:
	POLYID [type_ifaces]
	name [type_args]
type_ifaces:
	"(" name {"," name} ")"
type_args:
	"[" type {"," type} "]"


let_decl:
	"let" ID ":" type
	"let" ID "=" exp


impl:
	"impl" ID ":" type "{" {fn_decl} "}"
	"impl" type        "{" {fn_decl} "}"


iface:
	"iface" ID [POLYID] "{" {fn_iface} "}"
fn_iface:
	fn_sig ":" type


exp:
	exp1 {op1 exp1}
exp1:
	exp2 {op2 exp2}
exp2:
	exp3 [op3 exp2]
exp3:
	exp4 {op4 exp4}
exp4:
	term {op5 term}
op1:
	"or"
	"and"
op2:
	"<"
	"<="
	"=="
	"!="
	">="
	">"
op3:
	"::"
op4:
	"+"
	"-"
op5:
	"*"
	"/"
	"%"
op_unary:
	"not"
	"-"
assignment:
	"=" exp


term:
	op_unary term
	prefix_term {term_suffix}
prefix_term:
	name
	INT
	REAL
	LONG
	STRING
	bool_exp
	tuple_exp
	lambda_exp
	object_exp
	cond_exp
	block_exp
term_suffix:
	"(" [exp {"," exp}] ")"
	"." ID
	"[" exp "]"


bool_exp:
	"true"
	"false"

tuple_exp:
	"(" [exp {"," exp}] ")"

lambda_exp:
	"fn" "(" [ID {"," ID}] ")" fn_body

object_exp:
	"new" type "{" [init {"," init}] "}"
init:
	ID "=" exp

block_exp:
	"{" {stmt} [final_stmt] "}"
stmt:
	";"
	let_decl
	cond_if [cond_else]
	loop
	exp [assignment]
final_stmt:
	"return" [exp]
	"break"
	"continue"

cond_if:
	"if" exp block
cond_else:
	"else" cond_if
	"else" block
cond_exp:
	cond_if cond_else_exp
cond_else_exp:
	"else" cond_exp
	"else" block

loop:
	"while" exp block_exp
	"for" exp "in" exp block_exp
