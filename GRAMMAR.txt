// grammar rules (EBNF-like)
// to be theoretically generated by
//  an LL(2) parser-generator
// but it's going to use a handwritten
//  recursize-descent parser

language:
	{toplevel}

toplevel:
	"module" ID
	"use" ID
	impl
	["pub"] fn_decl
	["pub"] type_decl
	["pub"] let_decl
	["pub"] iface_decl


name:
	ID "::" ID
	ID
var:
	ID ":" type


impl:
	"impl" [ID ":"] type "{" {fn_decl} "}"


fn_decl:
	fn_sig fn_body
fn_sig:
	"fn" ID "(" [var {"," var}] ")"
fn_body:
	"=" exp
	"extern" STRING ":" type
	block_exp


let_decl:
	"let" ID ":" type
	"let" ID "=" exp


type_decl:
	"type" type "{" [var {"," var}] "}"


iface_decl:
	"iface" [POLYID ":"] type "{" {iface_fn} "}"
iface_fn:
	"fn" ID "(" [type {"," type}] ")" ":" type


type:
	POLYID [type_ifaces]
	name [type_args]
	fn_type
	tuple_type
type_ifaces:
	"(" type {"," type} ")"
type_args:
	"[" type {"," type} "]"
fn_type:
	"fn" "(" [type {"," type}] ")" "->" type
tuple_type:
	"(" [type {"," type}] ")"


exp:
	exp1 {op1 exp1}
exp1:
	exp2 {op2 exp2}
exp2:
	exp3 [op3 exp2]
exp3:
	exp4 {op4 exp4}
exp4:
	term {op5 term}
op1:
	"or"
	"and"
op2:
	"<"
	"<="
	"=="
	"!="
	">="
	">"
op3:
	"::"
op4:
	"+"
	"-"
op5:
	"*"
	"/"
	"%"
op_unary:
	"not"
	"-"
assignment:
	"=" exp


term:
	op_unary term
	prefix_term {term_suffix}
prefix_term:
	name
	INT
	REAL
	LONG
	STRING
	bool_exp
	tuple_exp
	list_exp
	lambda_exp
	object_exp
	cond_exp
	block_exp
term_suffix:
	"(" [exp {"," exp}] ")"
	"." ID
	"[" exp "]"


bool_exp:
	"true"
	"false"

tuple_exp:
	"(" [exp {"," exp}] ")"

list_exp:
	"[" [exp {"," exp}] "]"

lambda_exp:
	"fn" "(" [ID {"," ID}] ")" fn_body

object_exp:
	"new" type "{" [init {"," init}] "}"
init:
	ID "=" exp

block_exp:
	"{" {stmt} [final_stmt] "}"
stmt:
	";"
	let_decl
	cond_if [cond_else]
	loop
	exp [assignment]
final_stmt:
	"return" [exp]
	"break"
	"continue"

cond_if:
	"if" exp block
cond_else:
	"else" cond_if
	"else" block
cond_exp:
	cond_if cond_else_exp
cond_else_exp:
	"else" cond_exp
	"else" block

loop:
	"while" exp block_exp
	"for" exp "in" exp block_exp
